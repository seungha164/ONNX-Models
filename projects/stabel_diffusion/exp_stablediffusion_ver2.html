<html lang="en">
	<head>
		<title>EXP WEBGPU for LLE</title>
	</head>
	<body>
        <h1>ONNXRUNTIME Text to Image TEST</h1>
        <h2>model name : Stable Diffusion</h2>
        <img src="https://github.com/CompVis/stable-diffusion/raw/main/assets/stable-samples/txt2img/merged-0006.png", width="100%">
        
        <br>
        <input type="text" placeholder="Enter your prompt" size="100%" id="prompt"/>
		<!-- RGB, ÎßàÏä§ÌÅ¨ Ïù¥ÎØ∏ÏßÄÎ•º ÏûÖÎ†•Î∞õÎäî Î≤ÑÌäº -->
        <!--<input type="file" id="imageUpload" accept="image/*">-->
		<button type="button" id="inference">Generate image</button>


		<!-- ÏûÖÎ†• Î∞õÏùÄ Ïù¥ÎØ∏ÏßÄÎ•º Î≥¥Ïó¨Ï§Ñ Ïª®ÌÖåÏù¥ÎÑà -->
		<!-- <div class="row">
			<div id="rgb_div"></div>
		</div>-->


		<!-- Í≤ÄÏ¶ù Í≤∞Í≥ºÎ¨ºÏù¥ Í∑∏Î†§ÏßÄÎäî Ï∫îÎ≤ÑÏä§ -->
		<canvas id="predicted"></canvas>

        <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
		<script src="https://code.jquery.com/jquery-1.11.3.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/mathjs@11.8.0/lib/browser/math.min.js"></script>
        <script src="static/dist/ort.webgpu.min.js"></script>
        <script src="static/js/utils.js"></script>
        <!-- <script src="static/js/utils_bisenet.js"></script> -->
        <!-- <script src="https://127.0.0.1:5500/../static/dist/ort.webgpu.min.js"></script> -->
        <!-- <script src="https://127.0.0.1:5500/static/js/utils.js"></script>
        <script src="https://127.0.0.1:5500/static/js/utils_bisenet.js"></script> -->
		<script>
            function postprocessing_and_html2(result, outputSizeH, outputSizeW, id = "predicted"){
    
                console.time("post-processing");
                // ImageData ÏÉùÏÑ±(RGB Í≥†Î†§)
                const output = result.cpuData;
                const imgData = new ImageData(outputSizeH, outputSizeW);
                const dData = imgData.data;
            
                for(let i=0; i< outputSizeH*outputSizeW; i++){
                    originIdx = i * 3;
                    imgIdx = i * 4;
                    dData[imgIdx+0] = Number(output[originIdx]);
                    dData[imgIdx+1] = Number(output[originIdx+1]);
                    dData[imgIdx+2] = Number(output[originIdx+2]); 
                    dData[imgIdx+3] = 255;
                    
                }
                
                var   canvasHTML  = document.getElementById(id);
                canvasHTML.width  = outputSizeW;
                canvasHTML.height = outputSizeH;
                let context = canvasHTML.getContext("2d");
                
                context.putImageData(imgData, 0, 0);
                
                console.timeEnd("post-processing");
            };
        
			// infer Î≤ÑÌäº ÎàÑÎ•¥Î©¥ ÏãúÏûë ÎêòÎäî Ìï®Ïàò
			async function inference(sessionTe, sessionUnetPre, sessionUNet, sessionUnetPost, scheulers_session, sessionDe){
                            
                console.log('üçª[step 1] Text Encoder');
                // Ï†ÑÏ≤òÎ¶¨ ÏΩîÎìú ÎåÄÏ≤¥ (ÏûÑÏãú)
                // var text = document.getElementById("prompt").value;
                var tokenizer = new Array(77).fill(0.2)
                tokenizer = new ort.Tensor("float32", tokenizer, [1, 77]);
                var results = await sessionTe.run({});
                outTembed = results.out_sample.reshape([2, 77, 768]);
                

                console.log('üçªüçª[step 2] Denoising');
                var latents = new Array(1*4*64*64).fill(0.2);                       // random latents
                latents = new ort.Tensor("float32", latents, [1, 4, 64, 64]);       // [1 4 64 64]
                timesteps = [981, 961, 961, 941, 921, 901, 881, 861, 841, 821, 801, 781, 761, 741, 721, 701, 681, 661, 641, 621, 601, 581, 561, 541, 521, 501, 481, 461, 441, 421, 401, 381, 361, 341, 321, 301, 281, 261, 241, 221, 201, 181, 161, 141, 121, 101, 81, 61, 41, 21, 1]
                for(let i = 0; i < timesteps.length; i++){
                    t = timesteps[i];
                    // 1) Unet
                    var unetInput = await sessionUnetPre.run({
                        "latents": latents              // [1 4 64 64]
                    });                                 // [2 4 64 64]
                    unetInput = unetInput.latents_out;
                    
                    var timestep =  new ort.Tensor("float32", [t]);
                    // noise_pred = await sessionUNet.run({
                    //     "sample": unetInput,
                    //     "timestep" : timestep,
                    //     "encoder_hidden_states" : outTembed
                    // });
                    unet_output = unetInput;
                    noise_pred = await sessionUnetPost.run({
                        "noise_pred": unet_output
                    });
                    noise_pred = noise_pred.noise_pred_out;

                    // 2) Scheduler
                    if(t == 981){
                        ets0 = noise_pred;
                        var outp_s981 = await scheulers_session[t].run({
                            'noise_pred'    : noise_pred,               // [1, 4, 64, 64]
                            'latents'       : latents,                  // [1, 4, 64, 64]
                        });
                        var cur_sample = outp_s981.prev_cur_latents;
                        latents = outp_s981.cur_sample;
                    }
                    else if(t == 961 && i == 1){
                        latents = await scheulers_session['961_1'].run({
                            'noise_pred'    : noise_pred,               // [1, 4, 64, 64]
                            'sample'        : cur_sample,               // [1, 4, 64, 64]
                            'ets'           : ets0                      // [1, 4, 64, 64]
                        });
                        latents = latents.prev_cur_latents;
                    }
                    else if(t == 961 && i == 2){
                        latents = await scheulers_session['961_2'].run({
                            'noise_pred'    : noise_pred,               // [1, 4, 64, 64]
                            'sample'        : latents,                  // [1, 4, 64, 64]
                            'ets'           : ets0                      // [1, 4, 64, 64]
                        });
                        latents = latents.prev_cur_latents;
                        ets1 = noise_pred;
                    }
                    else if(t == 941){
                        var latents = await scheulers_session[t].run({
                            'noise_pred' : noise_pred,                  // [1, 4, 64, 64]
                            'sample' : latents,                         // [1, 4, 64, 64]
                            'ets1' : ets0,                              // [1, 4, 64, 64]
                            'ets2' : ets1                               // [1, 4, 64, 64]
                        });
                        latents = latents.prev_cur_latents;
                        ets2 = noise_pred;
                    }
                    else{
                        var latents = await scheulers_session[t].run({
                            'noise_pred' : noise_pred,                  // [1, 4, 64, 64]
                            'latents' : latents,                        // [1, 4, 64, 64]
                            'ets1' : ets0,                              // [1, 4, 64, 64]
                            'ets2' : ets1,                              // [1, 4, 64, 64]
                            'ets3' : ets2                               // [1, 4, 64, 64]
                        });
                        latents = latents.prev_cur_latents;
                        ets0 = ets1;
                        ets1 = ets2;
                        ets2 = noise_pred;
                    }
                }
                
                console.time('üçªüçª[step 3] Decoder');
                var output = await sessionDe.run({
                    latent_sample : latents     // latents : [1 4 64 64]
                });                             // output  : [1 512 512 3]
                console.log(output);
                //* ÌõÑÏ≤òÎ¶¨
                postprocessing_and_html2(output.output, 512, 512);  
			};
            
            async function main(){

                // inference Ìï®ÏàòÎ•º Ïã§ÌñâÌï† Î≤ÑÌäº
                var     prompt = document.getElementById("prompt");
                var     infer_btn  = document.getElementById("inference");
                
                // Î™®Îç∏ Î°úÎî©
                console.log('‚úÖ Text Encoder loading .. ')
                const te_session = await load_model("static/models/dove/TextEncoder_test/TextEmbedding-test-quant.onnx", 'cpu');
                
                console.log('‚úÖ Denoising > Unet loading .. ')
                const unet_pre_session = await load_model("static/models/dove/UNetPre/model-quant.onnx", 'cpu');
                // const unet_session = await load_model("static/models/dove/UNetRaw/model-quant.onnx", 'cpu');
                const unet_post_session = await load_model("static/models/dove/UNetPost/model-quant.onnx", 'cpu');
                
                console.log('‚úÖ Denoising > Schedulers loading .. ')
                var schedulers = {}
                var session = 0
                for(var i=1 ; i<=981 ; i+=20){
                    if(i == 961){
                        session = await load_model("static/models/dove/schedulers/step-" + i + "_1.onnx", 'cpu');
                        schedulers[''+i +'_1'] = session
                        session = await load_model("static/models/dove/schedulers/step-" + i + "_2.onnx", 'cpu');
                        schedulers[''+i +'_2'] = session
                    }
                    else{
                        session = await load_model("static/models/dove/schedulers/step-" + i + ".onnx", 'cpu');
                        schedulers['' + i] = session
                    }
                }
                
                console.log('‚úÖ VAE Decoder loading .. ')
                const de_session = await load_model("static/models/dove/Decoder/Decoder-quant.onnx", 'cpu');

                // inference Î≤ÑÌäºÏù¥ ÎàåÎ¶¨Î©¥ Ïã§ÌñâÎêòÎäî Ïù¥Î≤§Ìä∏
                infer_btn.addEventListener("click", function(){
                    inference(te_session, unet_pre_session, unet_post_session, unet_post_session, schedulers, de_session).then();
                });
                
                console.log('Ï§ÄÎπÑ ÏôÑÎ£å');
            }

            main();
		</script>

	</body>
</html>
